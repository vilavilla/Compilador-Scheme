DEBUG: Leyendo archivo 'prueba.scm'...
DEBUG: Iniciando procesamiento de entrada...
DEBUG: Texto de entrada recibido:
DEBUG: Lexer inicializado.
DEBUG: TokenStream generado.
DEBUG: Parser inicializado.
DEBUG: √Årbol AST generado:
(root (declaration ( define ( es-par n ) (block (stmt (expr ( = (expr ( mod (expr n) (expr 2) )) (expr 0) )))) )) (declaration ( define ( es-impar n ) (block (stmt (expr ( (expr not (expr ( (expr es-par (expr n)) ))) )))) )) (expr ( display (expr ( (expr es-par (expr 2)) )) )) (expr ( newline )) (expr ( display (expr ( (expr es-par (expr 3)) )) )) (expr ( newline )) (expr ( display (expr ( (expr es-impar (expr 2)) )) )) (expr ( newline )) (expr ( display (expr ( (expr es-impar (expr 3)) )) )) (expr ( newline )) <EOF>)
DEBUG: Visitador inicializado.
DEBUG: Visitando nodo: RootContext, texto: (define(es-parn)(=(modn2)0))(define(es-imparn)(not(es-parn)))(display(es-par2))(newline)(display(es-par3))(newline)(display(es-impar2))(newline)(display(es-impar3))(newline)<EOF>
DEBUG: visitRoot - Start
DEBUG: visitRoot - Visiting child: (define(es-parn)(=(modn2)0))
DEBUG: Visitando nodo: FunctionDeclarationContext, texto: (define(es-parn)(=(modn2)0))
DEBUG: visitFunctionDeclaration - Function 'es-par' defined with params ['n'] and block (=(modn2)0)
DEBUG: Nodo FunctionDeclarationContext evaluado con resultado: es-par
DEBUG: visitRoot - Visiting child: (define(es-imparn)(not(es-parn)))
DEBUG: Visitando nodo: FunctionDeclarationContext, texto: (define(es-imparn)(not(es-parn)))
DEBUG: visitFunctionDeclaration - Function 'es-impar' defined with params ['n'] and block (not(es-parn))
DEBUG: Nodo FunctionDeclarationContext evaluado con resultado: es-impar
DEBUG: visitRoot - Visiting child: (display(es-par2))
DEBUG: Visitando nodo: DisplayExprContext, texto: (display(es-par2))
DEBUG: visitDisplayExpr - Start, texto: (display(es-par2))
DEBUG: Visitando nodo: GroupExprContext, texto: (es-par2)
DEBUG: visitGroupExpr - Start, texto: (es-par2)
DEBUG: Visitando nodo: FunctionCallExprContext, texto: es-par2
DEBUG: Error capturado: not enough values to unpack (expected 3, got 2)
DEBUG: Procesamiento completado.

Resultados:
IN: (define (es-par n)
  (= (mod n 2) 0)) ; Devuelve #t si n es divisible por 2

(define (es-impar n)
  (not (es-par n))) ; Devuelve lo opuesto de es-par

; Pruebas
(display (es-par 2)) ; Esperado: #t
(newline)

(display (es-par 3)) ; Esperado: #f
(newline)

(display (es-impar 2)) ; Esperado: #f
(newline)

(display (es-impar 3)) ; Esperado: #t
(newline) /// OUT: Error: not enough values to unpack (expected 3, got 2)
Funciones definidas:
es-par (n)
es-impar (n)
